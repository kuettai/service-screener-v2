import boto3, json, botocore
from botocore.exceptions import BotoCoreError
from botocore.config import Config as bConfig
from utils.Config import Config
from datetime import datetime
from utils.Tools import _warn
import time

## --others '{"WA": {"region": "ap-southeast-1", "reportName":"SS_Report", "newMileStone":0}}'

class WATools():
    DEFAULT_REPORTNAME = 'SS_Report'
    DEFAULT_NEWMILESTONE = 0
    waInfo = {
        'isExists': False,
        'WorkloadId': None,
        'LensesAlias': 'wellarchitected'
    }

    HASPERMISSION = True

    def __init__(self, pillarId):
        self.pillarId = pillarId
        self.waInfo = {
            'isExists': False,
            'WorkloadId': None,
            'LensesAlias': 'wellarchitected'
        }

        pass

    def preCheck(self, params):
        if not 'reportName' in params:
            params['reportName'] = self.DEFAULT_REPORTNAME

        if not 'newMileStone' in params:
            params['newMileStone'] = 0

        if not 'region' in params:
            params['region'] = Config.get('REGIONS_SELECTED')[0]

        print("*** [WATool] Attempting to deploy WA Tools in this region: {}".format(params['region']))
        self.region = params['region']
        
        return True

    def init(self, cfg):
        self.cfg = cfg 
        self.stsInfo = Config.get('stsInfo')

        boto3Config = bConfig(region_name = cfg['region'])
        ssBoto = Config.get('ssBoto', None)

        self.waClient = ssBoto.client('wellarchitected', config=boto3Config)


    def checkIfReportExists(self):
        workload_name = self.cfg['reportName']
        try:
            # List workloads with the given name prefix
            response = self.waClient.list_workloads(
                WorkloadNamePrefix=workload_name,
                MaxResults=50  # Adjust this value as needed
            )

            # Check if any workload matches the exact name
            for workload in response.get('WorkloadSummaries', []):
                if workload['WorkloadName'] == workload_name:
                    self.waInfo['isExists'] = True 
                    self.waInfo['WorkloadId'] = workload['WorkloadId']

        except Exception as e:
            _warn(f"Error checking if workload exists: {str(e)}")
            self.HASPERMISSION = False
            return False, None
        
    def createReportIfNotExists(self):
        workload_name = self.cfg['reportName']
        self.checkIfReportExists()

        if self.HASPERMISSION == False:
            return False

        if self.waInfo['isExists'] == True:
            return True

        wLargs = {
            'WorkloadName': workload_name,
            'Description': 'Auto generated by ServiceScreener',
            'Environment': 'PRODUCTION',
            'AccountIds': [self.stsInfo['Account']],
            'AwsRegions': [self.region],
            'ReviewOwner': self.stsInfo['Arn'],
            'Lenses': [self.waInfo['LensesAlias']]
        }

        try:
            response = self.waClient.create_workload(**wLargs)
            self.waInfo['WorkloadId'] = response['WorkloadId']
            return True
        except Exception as e:
            self.HASPERMISSION = False
            print(f"An error occurred while creating the workload: {str(e)}")
            return False
        
    def _get_latest_milestone(self):
        """Helper method to get the latest milestone for a workload"""
        all_milestones = []
        next_token = None

        while True:
            params = {
                'WorkloadId': self.waInfo['WorkloadId'],
                'MaxResults': 20
            }
            if next_token:
                params['NextToken'] = next_token

            response = self.waClient.list_milestones(**params)
            all_milestones.extend(response['MilestoneSummaries'])

            next_token = response.get('NextToken')
            if not next_token:
                break  # No more pages, exit the loop

        if not all_milestones:
            return False

        # Sort milestones by date (most recent first)
        sorted_milestones = sorted(
            all_milestones,
            key=lambda x: x['RecordedAt'],
            reverse=True
        )

        # Get the latest milestone
        latest_milestone = sorted_milestones[0]
        self.waInfo['MilestoneName'] = latest_milestone['MilestoneName']
        self.waInfo['MilestoneNumber'] = latest_milestone['MilestoneNumber']
        return True

    def createMilestoneIfNotExists(self):
        if self.cfg['newMileStone'] == 1:
            self.createMilestone()
            return

        try:
            if not self._get_latest_milestone():
                print("No milestones found for workload {}... creating milestone...".format(self.waInfo['WorkloadId']))
                self.createMilestone()
        except BotoCoreError as e:
            print(f"An error occurred: {str(e)}")
            return None
        
    def createMilestone(self):
        max_retries = 3
        retry_delay = 2  # seconds
        
        for attempt in range(1, max_retries + 1):
            cdate = datetime.now().strftime('%Y%m%d%H%M%S')
            milestoneName = f'SS-{cdate}-{attempt}'
            
            try:
                resp = self.waClient.create_milestone(
                    WorkloadId=self.waInfo['WorkloadId'],
                    MilestoneName=milestoneName
                )
                
                print(f"Milestone Number: {resp['MilestoneNumber']}")
                self.waInfo['MilestoneName'] = milestoneName
                self.waInfo['MilestoneNumber'] = resp['MilestoneNumber']
                return True
                
            except Exception as e:
                if 'ConflictException' in str(e.__class__) or 'Conflict' in str(e):
                    print(f"Attempt {attempt}/{max_retries}: Milestone conflict: {str(e)}")
                    if attempt < max_retries:
                        print(f"Retrying in {retry_delay} seconds...")
                        time.sleep(retry_delay)
                        continue
                    
                    # All retries failed, try to get existing milestone
                    print("All creation attempts failed, trying to use existing milestone")
                    try:
                        if self._get_latest_milestone():
                            print(f"Using existing milestone: {self.waInfo.get('MilestoneName', 'Unknown')}")
                            return True
                        else:
                            _warn("No existing milestones found")
                            return False
                    except Exception as inner_e:
                        _warn(f"Failed to get existing milestone: {str(inner_e)}")
                        return False
                else:
                    # Re-raise if it's not a conflict exception
                    raise
                    
            except BotoCoreError as e:
                self.HASPERMISSION = False
                _warn(f"An error occurred while creating the milestone: {str(e)}")
                return None
        
    def listAnswers(self):
        if self.HASPERMISSION == False:
            return None

        next_token = None
        ansArgs = {
            'WorkloadId': self.waInfo['WorkloadId'],
            'LensAlias': self.waInfo['LensesAlias'],
            'PillarId': self.pillarId,
            # 'MilestoneNumber': self.waInfo['MilestoneNumber'],
            'MaxResults': 50
        }

        isSuccess = False
        maxRetry = 3
        currAttempt = 0
        while True:
            currAttempt = currAttempt + 1
            try:
                resp = self.waClient.list_answers(**ansArgs)
                isSuccess = True
                break
            except botocore.errorfactory.ResourceNotFoundException:
                # wait for 3 seconds before retrying
                print("*** [WATools] ListAnswer failed, waiting workload to be generated, retry in 3 seconds")
                if currAttempt >= maxRetry:
                    break
                time.sleep(3)
                
        if isSuccess == False:
            print("*** [WATools] Unable to retrieve list of checklists, skipped WATool integration")
            return None

        answers = []
        try:
            while True:
                if next_token:
                    ansArgs['nextToken'] = next_token

                resp = self.waClient.list_answers(**ansArgs)
                # print(resp['AnswerSummaries'])
                answers.extend(resp['AnswerSummaries'])

                next_token = resp.get('NextTOken')
                if not next_token:
                    break
        except BotoCoreError as e:
            _warn(f"[ERROR - WATOOLS]: {str(e)}")
            self.HASPERMISSION = False
            return None

        i = 1
        j = 1
        answerSets = {}
        for ans in answers:
            j = 1
            answerSets[f'{i:02}'] = [ans['QuestionId'], ans['QuestionTitle']]
            # print(ans['QuestionId'])
            for choice in ans['Choices']:
                # print(choice)
                fkey = f'{i:02}::{j:02}'
                answerSets[fkey] = [choice['ChoiceId'], choice['Title']]
                j = j+1
        
            i = i+1
            
        self.answerSets = answerSets
    
    def updateAnswers(self, questionId, selectedChoices, unselectedNotes):
        if self.HASPERMISSION == False:
            return None

        # Skip if questionId is None or empty
        if questionId is None or questionId == '':
            _warn(f"[WATOOLS]: Skipping update for invalid questionId: {questionId}")
            return None

        # Validate and clean selectedChoices
        if not selectedChoices:
            selectedChoices = []
        elif isinstance(selectedChoices, str):
            # If it's a string, convert to list
            selectedChoices = [selectedChoices] if selectedChoices.strip() else []
        elif isinstance(selectedChoices, list):
            # Filter out None and empty values, then remove duplicates
            original_count = len(selectedChoices)
            selectedChoices = [choice for choice in selectedChoices if choice is not None and choice != '']
            # Remove duplicates while preserving order
            selectedChoices = list(dict.fromkeys(selectedChoices))
            
            # Log if duplicates were found
            if len(selectedChoices) != original_count:
                _warn(f"[WATOOLS]: Removed duplicates/empty values for question {questionId}: {original_count} -> {len(selectedChoices)}")
        else:
            _warn(f"[WATOOLS]: Invalid selectedChoices type: {type(selectedChoices)}, converting to empty list")
            selectedChoices = []

        # Validate and clean unselectedNotes
        if unselectedNotes is None:
            unselectedNotes = ""
        elif not isinstance(unselectedNotes, str):
            unselectedNotes = str(unselectedNotes)
        
        # Truncate notes if too long (AWS limit is typically 2048 characters)
        if len(unselectedNotes) > 2000:
            unselectedNotes = unselectedNotes[:1997] + "..."
            _warn(f"[WATOOLS]: Truncated notes for question {questionId} (too long)")

        ansArgs = {
            'WorkloadId': self.waInfo['WorkloadId'],
            'LensAlias': self.waInfo['LensesAlias'],
            'QuestionId': questionId, 
            'SelectedChoices': selectedChoices,
            'Notes': unselectedNotes
        }

        try:
            # Additional validation before API call
            if not self.waInfo.get('WorkloadId'):
                _warn(f"[WATOOLS]: No WorkloadId available, skipping update for question {questionId}")
                return None
                
            if not self.waInfo.get('LensesAlias'):
                _warn(f"[WATOOLS]: No LensAlias available, skipping update for question {questionId}")
                return None

            resp = self.waClient.update_answer(**ansArgs)
            return resp
            
        except Exception as e:
            error_msg = str(e)
            if 'ValidationException' in error_msg:
                _warn(f"[ERROR - WATOOLS]: Validation failed for question {questionId}")
                _warn(f"[ERROR - WATOOLS]: QuestionId: {questionId}")
                _warn(f"[ERROR - WATOOLS]: SelectedChoices: {selectedChoices}")
                _warn(f"[ERROR - WATOOLS]: Notes length: {len(unselectedNotes)}")
                _warn(f"[ERROR - WATOOLS]: Validation error: {error_msg}")
            else:
                _warn(f"[ERROR - WATOOLS]: {error_msg}")
            
            # Don't disable permissions for validation errors, just skip this update
            if 'ValidationException' not in error_msg:
                self.HASPERMISSION = False
            return None