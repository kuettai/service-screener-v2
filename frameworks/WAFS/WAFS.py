import json, re

import constants as _C
from utils.Config import Config
from utils.Tools import _warn, _info
from frameworks.Framework import Framework
from frameworks.helper.WATools import WATools

class WAFS(Framework):
    WATools = None
    ResultCache = {}
    isBeta = False
    def __init__(self, data):
        super().__init__(data)
        self.isBeta = Config.get('beta', False)

        self.WATools = None
        waTools = WATools('security')
        cliParams = Config.get('_SS_PARAMS')

        tmpParams = {}
        self.ResultCache = {}
        if 'others' in cliParams and not cliParams['others'] == None:
            params = cliParams['others']
            cfg = json.loads(params)

            if 'WA' in cfg:
                tmpParams = cfg['WA']

        if waTools.preCheck(tmpParams): 
            self.WATools = waTools
            self.WATools.init(tmpParams)
            self.WATools.createReportIfNotExists()
            self.WATools.listAnswers()
            # print(self.WATools.answerSets)
        

    def _hookPostItemActivity(self, title, section, checks, comp):
        if self.WATools == None or self.WATools.HASPERMISSION == False:
            return title, section, checks, comp
        
        titleNum = self.extractNumber(title)
        sectNum = self.extractNumber(section)

        paired = "{}::{}".format(titleNum, sectNum)

        newChecks = "<h4>{}</h4>{}".format(self.getDescription(titleNum, paired), checks) 

        titleKey = self.WATools.answerSets.get(titleNum, [None])[0]
        if not titleKey in self.ResultCache:
            self.ResultCache[titleKey] = {
                "0": [],
                "1": [],
                "-1": []
            }

        if not titleKey == None:
            if comp == 1:
                choice = self.WATools.answerSets.get(paired, [None])[0]
                if choice and choice not in self.ResultCache[titleKey]["1"]:
                    self.ResultCache[titleKey]["1"].append(choice)
            elif comp == -1:
                choice = self.WATools.answerSets.get(paired, [None, None])[1]
                if choice and choice not in self.ResultCache[titleKey]["-1"]:
                    self.ResultCache[titleKey]["-1"].append(choice)
            else:
                choice = self.WATools.answerSets.get(paired, [None])[0]
                if choice and choice not in self.ResultCache[titleKey]["0"]:
                    self.ResultCache[titleKey]["0"].append(choice)

        return title, section, newChecks, comp
        
    def _hookPostItemsLoop(self):
        if self.WATools == None or self.WATools.HASPERMISSION == False:
            return

        for title, opts in self.ResultCache.items():
            if len(opts["1"]) == 0 and len(opts["-1"]) == 0:
                continue 

            # Validate title (questionId)
            if title is None or title == '':
                _warn(f"[WAFS]: Skipping invalid title/questionId: {title}")
                continue

            # Clean and validate selectedChoices
            ansStr = opts["1"]
            if isinstance(ansStr, list):
                # Filter out None and empty values, then remove duplicates
                ansStr = [choice for choice in ansStr if choice is not None and choice != '']
                ansStr = list(dict.fromkeys(ansStr))  # Remove duplicates while preserving order
            elif ansStr is None:
                ansStr = []
            
            # Validate unselectedNotes
            failed_items = opts["-1"]
            if isinstance(failed_items, list):
                # Filter out None and empty values, then remove duplicates
                failed_items = [item for item in failed_items if item is not None and item != '']
                failed_items = list(dict.fromkeys(failed_items))  # Remove duplicates
            
            if failed_items:
                unselectedNotes = "***Generated by SS\n\nHere are the items failed SS checks (if any):\n- {}".format("\n- ".join(failed_items))
            else:
                unselectedNotes = "***Generated by SS\n\nNo failed items found."

            # Only call updateAnswers if we have valid data
            if title and (ansStr or unselectedNotes):
                try:
                    self.WATools.updateAnswers(title, ansStr, unselectedNotes)
                except Exception as e:
                    _warn(f"[WAFS]: Error updating answers for {title}: {str(e)}")
            else:
                _warn(f"[WAFS]: Skipping update for {title} - insufficient data")

        pass

    def extractNumber(self, s):
        match = re.search(r'\d+', s)
        return match.group() if match else None
    
    def getDescription(self, titleNum, paired):
        titleStr = self.WATools.answerSets.get(titleNum, [None])[1]
        sectStr = self.WATools.answerSets.get(paired, [None])[1]
        return f"{titleStr} - {sectStr}"

    def _hookPostBuildContentDetail(self):
        self.WATools.createMilestoneIfNotExists()